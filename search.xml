<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解算法]]></title>
    <url>%2F2019%2F08%2F12%2Funderstand-algorithm%2F</url>
    <content type="text"><![CDATA[从广义上说，任何程序代码都是算法，表示一组可被人机识别的操作序列。 算法、设计模式、架构模式都可以统一视为解决特定问题的方案，我们需要用适用于各自的语言进行描述。在大多数情况下，我们可能用不到，我们需要结合具体的应用场景去分析。 同样的，算法、数据结构、设计模式、架构模式的学习，也应该采取一致的学习方式，渐进增强的方式是不错的，尤其是对进入工作中的人来说，我们可能没有时间进行系统的学习。 解决同一个问题，可能有多种算法，我们需要通过比较算法的时间复杂度和空间复杂度来选择算法。 算法是语言无关的，可以使用 伪代码 描述算法。 观点 数据结构与算法都是能从常识中推到出来的。数学里的一切都是可以用常识去解释的。 解题策略递归 递归只是让解决方案更清晰，并没有性能上的优势。如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。 编写递归函数时，必须告诉它何时停止递归。每个递归函数都有两部分：基线条件和递归条件。 递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。 使用 尾递归！ 分而治之D&amp;C 算法是递归的。 使用 D&amp;C 算法解决问题的过程包括两个步骤： 找出基线条件，这种条件必须尽可能简单； 不断将问题分解（或者说缩小规模），直到符合基线条件。 D&amp;C 是一种解决问题的思路。 数据结构链表1class Node &lt; Struct.new(:item, :next); end 栈栈是一种先进后出的数据结构，可以视为功能受限的线性表，只能在尾部进行插入或删除并读取操作。 12345ary = ["a", "b", "c", "d"]ary.popary.push("d") 压入和弹出操作： 12345678910111213141516171819```### 散列表## 查找算法给定数组 ary = [0, 4, 7, 10, 12] , 查找 7。```rubyary = [0, 4, 7, 10, 12]ary.bsearch &#123; |x| x == 7 &#125;ary.bsearch_index &#123; |x| x == 7 &#125;ary.one? &#123; |x| x == 7 &#125;ary.none? &#123; |x| x == 7 &#125; 简单查找123456def search(ary, key) ary.each_with_index do |item, index| return index if item == key end nilend 二分查找二分查找是基于有序的数组实现的。算法时间复杂度为 O(log n)。 1234567891011121314def binary_search(ary, key) low, high = 0, ary.length - 1 while high &gt;= low mid = (low + high) / 2 if ary[mid] &gt; key high = mid - 1 elsif ary[mid] &lt; key low = mid + 1 else return mid end end nilend 排序算法对随机整型数组从大到小排序。 12345expect = [7, 6, 5, 4, 3, 2, 1]ary = [7, 6, 5, 4, 3, 2, 1].shuffleary.sort &#123; |a, b| b - a &#125; 选择排序12345678910111213141516171819def max(ary) target = ary.first ary.each do |item| target = item &gt; target ? item : target end targetenddef sort(ary) ary.length.times do |n| max = max(ary) ary.each do |item| max = item &gt; target ? item : target end target[n] = max ary = ary - [max] end targetend 快速排序12345678def qsort(ary) return ary if ary.length &lt;= 1 pivot = ary.first lt = ary.select &#123; |item| item &lt; pivot &#125; gt = ary.select &#123; |item| item &gt; pivot &#125; qsort(lt) + [pivot] + qsort(gt)end 冒泡排序12345678910def bubble_sort(ary) ary.length.times do |n| ary.each_with_index do |item, i| break if i + 1 == ary.length ary[i], ary[i + 1] = ary[i + 1], ary[i] if item &lt; ary[i + 1] end end aryend 插入排序123456789def insertion_sort(ary) ary.length.times do |n| ary.each_with_index do |item, i| break if n + 1 == ary.length ary[i], ary[n + 1] = ary[n + 1], ary[i] if item &lt; ary[n + 1] end end aryend 希尔排序归并排序堆排序图算法广度优先搜索算法分析参考 《图解算法》 《数据结构与算法图解》 徐树荣的 Ruby 算法笔记]]></content>
      <categories>
        <category>Understand</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人技术栈]]></title>
    <url>%2F2019%2F08%2F08%2Fpersonal-tech-stack%2F</url>
    <content type="text"><![CDATA[我就是我，是颜色不一样的烟火。 每个公司都有自己的技术栈，经历过一些公司，慢慢形成了自己的技术栈。 主机 minikube 数据库系统 MySQL PostgreSQL Redis 后端 Rails Play Framework(Scala) 接口 REST GraphQL gRPC 前端 Vue React CI/CD Jenkins 协作 Github/Phabricator DingDing/BearyChat Jira/Teambition Invision]]></content>
      <categories>
        <category>Person</category>
      </categories>
      <tags>
        <tag>Resume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序运行原理剖析]]></title>
    <url>%2F2019%2F08%2F06%2Fprogram-under-a-microscope%2F</url>
    <content type="text"><![CDATA[《程序是怎样跑起来的》摘录。 程序的运行过程是一个复杂的过程，《程序是怎样跑起来的》只呈现了一个完整的、粗糙的视图，但对消解程序运行机理的神秘感却极为有益。 《程序是怎么跑起来的》中的一些观点，也能够给人以启迪，如“程序员只需要了解寄存器即可”，计算机中的实体，都是相对透明的，可以视为不存在，直到你关注它。 抽象的力量是无穷的！ 我们可以按照计算机启动的过程来构建程序运行过程中涉及的知识。 了解程序运行原理，熟悉程序运行过程中涉及的软件和硬件，有助于构建一个大的知识背景。 计算机系统是一个抽象层次体系，我们可能工作在不同的抽象层上，我们可能关注不同的系统行为，我们可以不关心，但不能不知道。 引子程序 = 指令 + 数据（用于运算的数值/表示内存地址的数值） 程序员只需要了解寄存器即可！ 程序是把寄存器作为对象来描述的。在程序员看来，CPU 是寄存器的集合体。 所谓的控制，就是指数据运算以外的处理（主要是数据输入输出的时机控制） 计算机电子部件 IC，IC 引脚 0V 和 5V，该特性决定了计算机的信息数据只能用二进制数来处理。 有了二进制，加上布尔逻辑，我们就可以实现基本的逻辑电路了。 集成电路(IC): CPU = 寄存器 + 控制器 + 运算器 + 时钟(时钟信号/电流信号) 从物理上（硬件）和逻辑上（软件）理解程序是怎么跑起来的！ 寄存器 累加寄存器(1) 标志寄存器(1) 程序计数器(1) 基址寄存器(n) 变址寄存器(n) 通用寄存器(n) 指令寄存器(1) 栈寄存器(1) 内存物理上(DRAM/SRAM/ROM) -&gt; IC 电源 VCC/GND 地址信号 A0~An 数据信号 D0~Dn 控制信号 RD/WR 使能 RD，读取 D使能 WR，写入 A 逻辑上1 字节类型的数组和内存的物理构造完全一致。 指令 数据传输指令(寄存器和内存/内存和内存/寄存器和外围设备之间的数据读写操作) 运算指令(用累加寄存器执行算术运算/逻辑运算/比较运算/移位运算) 跳转指令(实现条件分支/循环/强制跳转等) call/return 指令(函数的调用/返回调用前的地址) 数据数据是用二进制表示的。 数据结构 队列 栈 链表 二叉树 磁盘利用操作系统的系统调用可以实现对硬件的控制。 操作系统借助输入输出指令控制硬件。 IN 指令通过指定端口号的端口输入数据，并将其存储在 CPU 内部的寄存器中；OUT 指令将存储在 CPU 寄存器中的数据，输出到指定端口号的端口。 主机 - 连接器（IO控制器）- 外设 IO 控制器中有用于临时保存输入输出数据的内存，这个内存就是端口。 各端口之间通过端口号区分，端口号也称为 IO 地址。 中断处理：实施中断请求的是连接外围设备的 IO 控制器，负责实施中断处理程序的是 CPU。 用中断来实现实时处理。 DMA vs. IRQ 汇编使用助记符，包含指令和伪指令，汇编指令与机器指令一一对应。 汇编指令 = 操作码 [+ 操作数]。 通过查看汇编语言编写的源代码，就可以了解程序的本质了。 汇编：汇编代码 - 汇编器 - &gt; 机器代码反汇编（反向工程）：机器代码 - 反汇编程序 -&gt; 汇编代码 函数调用分支循环C 语言在 C 语言中，数据用变量表示，处理用函数表示，C 程序由变量和函数构成。 操作系统操作系统的原型是监控程序，负责程序的加载和运行。 初期的操作系统 = 监控程序 + 基本的输入输出程序 应用程序通过操作系统间接地控制硬件。 操作系统和高级编程语言都可以视为硬件的抽象。 设备驱动是操作系统的一部分，提供了同硬件进行基本的输入输出的功能。 运行环境=操作系统 + 硬件 开机 -&gt; BIOS -&gt; 引导程序 -&gt; 操作系统 -&gt; 系统软件 + 应用软件 跑起来 CPU 的基本工作是执行存储的指令序列，即程序。程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程。 CPU 从存放程序的主存储器里取出一条指令，译码并执行这条指令，保存执行结果，紧接着又去取指令，译码，执行指令……，如此周而复始，反复循环，使得计算机能够自动地工作。除非遇到停机指令，否则这个循环将一直进行下去。 几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段： 取指令 指令译码 执行指令 访存取数和结果写回 计算机设计的基本思想是 “程序存储控制”，即程序存储和程序控制。 当一台裸机按下电源键，咦？安装一个 GNU/Linux 操作系统，就这样跑起来了！ 背后的机理有些烦复，待续…… 参考 CPU的工作过程]]></content>
      <categories>
        <category>Microscope</category>
      </categories>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解分布式系统]]></title>
    <url>%2F2019%2F08%2F04%2Fmaster-distributed-system%2F</url>
    <content type="text"><![CDATA[分布式的本质是——拆分与连接。 中心化设计 vs. 去中心化设计分布式 vs. 集群分布式：一个业务拆分成多个子业务，部署在不同的服务器上；集群：同一个业务，部署在多个服务器上。 CAP定理BASE理论参考 分布式系统的经典基础理论]]></content>
      <categories>
        <category>Master</category>
      </categories>
      <tags>
        <tag>Architechture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通 Socket 编程]]></title>
    <url>%2F2019%2F08%2F02%2Fmaster-socket%2F</url>
    <content type="text"><![CDATA[抽象语义]]></content>
      <categories>
        <category>Master</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postgresql 实战]]></title>
    <url>%2F2019%2F08%2F01%2Fpostgresql-in-action%2F</url>
    <content type="text"><![CDATA[如果使用 Rails 做 Web 开发的话，几乎写不了几个 SQL；即使是用 Slick/ScalikeJDBC，我们也常常使用 DSL 而非 SQL。 最近几次数据迁移，测试大佬的 SQL 编程功力让我瞠目结舌，也让我意识到自己的 SQL 编程水平很低，是时候系统地补一下 SQL 编程方面的东西。 有人将 SQL 编程分为三个阶段： 第一阶段是面向过程化的SQL编程阶段在这一阶段，经常会有滥用各种工具（如游标、临时表、动态SQL语句等）的情况，而程序员自己通常意识不到他们正在引起破坏。 第二阶段是面向集合的SQL编程阶段从这一阶段开始，程序员开始相信那些说游标、临时表、动态SQL有害而永远不应该使用的“专家”。 第三阶段是融合的SQL编程阶段在这一阶段，SQL程序员不再迷恋所谓的专家，他们可能意识到即使是游标，也并不是在所有情况下都是无用和有害的。 我很认同这种观点，我也领教了面向集合的 SQL 编程的威力。 SQL 必知必会1TRUNCATE TABLE activities RESTART IDENTITY; SQL 奇技淫巧]]></content>
      <categories>
        <category>Action</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通 Tmux]]></title>
    <url>%2F2019%2F08%2F01%2Fmaster-tmux%2F</url>
    <content type="text"><![CDATA[为什么选择 Tmux？ 在 macOS 上，iTerm2 已经够用了。如果你想进一步提高工作效率，那就使用 Tmux 吧。 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-sensible'set -g @plugin 'tmux-plugins/tmux-resurrect'set -g @plugin 'tmux-plugins/tmux-continuum'# 把前缀键从 C-b 更改为 C-aset -g prefix C-a# 释放之前的 Ctrl-b 前缀快捷键unbind C-b# 设定前缀键和命令键之间的延时set -sg escape-time 1# 确保可以向其它程序发送 Ctrl-Abind C-a send-prefix# 把窗口的初始索引值从 0 改为 1set -g base-index 1# 把面板的初始索引值从 0 改为 1setw -g pane-base-index 1# 使用 Prefix r 重新加载配置文件bind r source-file ~/.tmux.conf \; display "Reloaded!"# 分割面板bind | split-window -h -c '#&#123;pane_current_path&#125;'bind - split-window -v -c '#&#123;pane_current_path&#125;'# 在面板之间移动bind h select-pane -Lbind j select-pane -Dbind k select-pane -Ubind l select-pane -R# 快速选择面板bind -r C-h select-window -t :-bind -r C-l select-window -t :+# 调整面板大小bind -r H resize-pane -L 5bind -r J resize-pane -D 5bind -r K resize-pane -U 5bind -r L resize-pane -R 5# 鼠标支持 - 如果你想使用的话把 off 改为 onsetw -g mouse on# 设置默认的终端模式为 256 色模式set -g default-terminal "xterm-256color"# 开启活动通知setw -g monitor-activity onset -g visual-activity on# 设置状态栏的颜色set -g status-fg whiteset -g status-bg black# 设置窗口列表的颜色setw -g window-status-fg cyansetw -g window-status-bg defaultsetw -g window-status-attr dim# 设置活动窗口的颜色setw -g window-status-current-fg whitesetw -g window-status-current-bg redsetw -g window-status-current-attr bright# 设置面板和活动面板的颜色set -g pane-border-fg greenset -g pane-border-bg blackset -g pane-active-border-fg whiteset -g pane-active-border-bg yellow# 设置命令行或消息的颜色set -g message-fg whiteset -g message-bg blackset -g message-attr bright# 设置状态栏左侧的内容和颜色set -g status-left-length 40set -g status-left "#[fg=green]Session: #S #[fg=yellow]#I #[fg=cyan]#P"# 设置状态栏右侧的内容和颜色# 15% | 28 Nov 18:15set -g status-right "#(~/battery Discharging) | #[fg=cyan]%d %b %R"set -g status-right 'Continuum status: #&#123;continuum_status&#125;'# 每 60 秒更新一次状态栏set -g status-interval 60# 设置窗口列表居中显示set -g status-justify centre# 开启 vi 按键setw -g mode-keys vi# 在相同目录下使用 tmux-panes 脚本开启面板unbind vunbind nbind v send-keys " ~/tmux-panes -h" C-mbind n send-keys " ~/tmux-panes -v" C-m# 临时最大化面板或恢复面板大小unbind Upbind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmpunbind Downbind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp# 把日志输出到指定文件bind P pipe-pane -o "cat &gt;&gt;~/#W.log" \; display "Toggled logging to ~/#W.log"run-shell ~/.tmux/plugins/tmux-continuum/continuum.tmuxrun -b '~/.tmux/plugins/tpm/tpm' 常用复制搜索参考 Tmux Wiki Tmux使用手册]]></content>
      <categories>
        <category>Master</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机网络]]></title>
    <url>%2F2019%2F07%2F31%2Fmaster-network%2F</url>
    <content type="text"><![CDATA[计算机网络的本质是数据通信和资源共享。 核心思想——分组交换。 基本概念URL/URI进程间通信IP 地址网络号和主机号 套接字和端口号TCP/IP 协议族ARP 协议网络硬件DHCP 服务器DHCP 即动态主机配置协议，解决 IP 地址分配问题。 主机必要信息：IP地址、子网掩码、DNS服务器IP地址 网卡DNS路由本地路由表网络软件 网络控制软件叫做协议栈。]]></content>
      <categories>
        <category>Master</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 实战]]></title>
    <url>%2F2019%2F07%2F30%2Fdocker-in-action%2F</url>
    <content type="text"><![CDATA[Docker 是一种构建和运行容器的流行工具。 提到 Docker， 就会提到物理机、虚拟机、容器三者的优缺点。 和虚拟机相比，容器仅需要封装应用和应用需要的依赖文件，实现轻量的应用运行环境，拥有比虚拟机更高的硬件资源利用率。 使用 Docker 可以将应用程序打包封装到一个容器中，该容器包含了应用程序的代码、运行环境、依赖库、配置文件等必需的资源。容器之间达到进程级别的隔离，在容器中的操作，不会影响道宿主机和其他容器，不会出现应用之间相互影响的情形。 使用 Docker 可以实现开发、测试和生产环境的统一化和标准化。 概念Dockerfile 构建出 Docker 镜像，通过 Docker 镜像运行 Docker 容器。 Docker 镜像镜像（Image）就是一堆只读层（read-only layer）的统一视角 Docker 容器容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 容器 = 镜像 + 读写层 一个运行态容器（running container）被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。 镜像层一个层并不仅仅包含文件系统的改变，它还能包含了其他重要信息。元数据（metadata）就是关于这个层的额外信息，它不仅能够让Docker获取运行和构建时的信息，还包括父层的层次信息。需要注意，只读层和读写层都包含元数据。 其他 Dockerfile Docker 仓库 Docker 主机 原理统一文件系统（union file system）命令在实际开发过程中，我几乎没有用到 docker 命令，而是使用 kubectl。 123docker versiondocker images 参考 Docker Get Started Visualizing Docker Containers and Images]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes 实战]]></title>
    <url>%2F2019%2F07%2F30%2Fkubernetes-in-action%2F</url>
    <content type="text"><![CDATA[Kubernetes 简称 k8s，是 Google 基于 Borg 开源的容器编排调度引擎。 Kubernetes 环境搭建在 macOS 上，搭建 Kubernetes 可以使用 kind 或 minikube。安装 Docker for Desktop 后，可以启用 kind。建议使用 minikube。 安装 minikubeminikube minikube implements a local Kubernetes cluster on macOS, Linux, and Windows.minikube’s primary goals are to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit. 12345brew cask install minikubeminikube startminikube dashboard 使用 minikube1234567891011121314151617181920212223242526kubectl create deployment echoserver --image=k8s.gcr.io/echoserver:1.10kubectl expose deployment echoserver --type=LoadBalancer --port=8080minikube service echoserver# 更多命令minikube service echoserver --urlkubectl get nodeskubectl get deploymentskubectl get serviceskubectl get podskubectl delete service echoserverkubectl delete deployment echoserverminikube stopminikube delete 小结Kubernetes 之旅123minikube service echoserver --url# =&gt; http://192.168.99.100:32359 浏览器访问在浏览器中输入 URL http://192.168.99.100:32359。 浏览器对 URL 进行解析。 VirtualBox 网络连接VirtualBox 有四种网络连接方式： NAT(Network Address Translation) Bridged Adapter Internal Host-only Adapter Mode VM -&gt; Host VM &lt;- Host VM1 VM2 VM -&gt; Net/LAN VM &lt;-Net/LAN Host-only + + + - - Internal - - + - - Bridged + + + + + NAT + Port forward - + Port forward NATservice + Port forward + + Port forward minikube 使用了 NAT 和 Host-only Adapter。 minikube 虚拟机 IP 地址 12VBoxManage guestproperty get minikube "/VirtualBox/GuestInfo/Net/0/V4/IP"#=&gt; Value: 10.0.2.15 In NAT mode,the default network range for VM on Virtualbox is 10.0.2.0/24.Host is 10.0.2.1 and the first VM should be 10.0.2.15. 登录 minikube-vm1234minikube status#=&gt; kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100minikube ssh 与 minikube-vm 通信从在浏览器中输入 URL 开始，浏览器完成自己的任务后，委托操作系统中的网络控制软件（协议栈）将消息发送给服务器。 我们可以忽略数据包在网络中传输的过程（交换机 -&gt; 路由器），关注网卡前后的传输路径，作为与 minikube-vm 通信的基本分析框架。 为了更直观的分析与 minikube-vm 通信的过程，我们会使用 Wireshark。 我们已经获得了访问对象服务器的IP地址，当然，我们已经明了 /etc/hosts 和 DNS。 接下来，我们跟踪一下网络包的转发过程。 查看路由表123456789101112131415161718192021ip route list# default via 192.168.55.254 dev en0# 127.0.0.0/8 via 127.0.0.1 dev lo0# 192.168.99.0/24 dev vboxnet scope linkip route get 192.168.99.100# 192.168.99.100 dev vboxnet0 src 192.168.99.1ip link show dev vboxnet0ip neigh show dev vboxnet0netstat -rn# Routing tables# Internet:# Destination Gateway Flags Refs Use Netif Expire# default 192.168.55.254 UGSc 401 0 en0# 127.0.0.1 127.0.0.1 UH 8 65400 lo0# 192.168.99.100 8:0:27:e9:86:e4 UHLWIi 1 215 vboxnet 1149 Wireshark 抓包 计算机网络见 《深入理解计算机网络》 分布式系统见 《深入理解分布式系统》 Kubernetes 对象PodControllerService远程调试 添加 remote 配置, 复制 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 粘贴到 K8S 的 deployment，JVM 参数 本地执行 kubectl -n namespace port-forward name 5005:5005 启动 参考 解读 ip 命令展示的网络连接信息 FreeBSD 使用手册-高级网络-网关和路由 Kubernetes中文指南/云原生应用架构实践手册]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超赞网站合集]]></title>
    <url>%2F2019%2F07%2F27%2Fawesome-website%2F</url>
    <content type="text"><![CDATA[真棒 网站! 网站列表 超赞合集]]></content>
      <categories>
        <category>Awesome</category>
      </categories>
      <tags>
        <tag>Website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超赞软件合集]]></title>
    <url>%2F2019%2F07%2F25%2Fawesome-software%2F</url>
    <content type="text"><![CDATA[超赞软件索引！ 曾经有一个超赞的软件我使用了很久，但是我没有收藏，等到换了电脑，忘了软件名称时才后悔莫及，那份悔恨记忆犹新。 如果可以给我一个机会再来一次的话，我会创建一个文档———超赞软件合集，我希望养成一个习惯，记下我遇到的每一个好软件。 macOS Karabiner A powerful and stable keyboard customizer for macOS. 插件Chrome OneTab Vimium Motivation VSCode Project Manager 微服务 Apache SkyWalking 命令行工具 iproute2mac wscat kubernetes-cli 123wscat -c wss://&lt;url&gt;/kubectl -n &lt;namespace&gt; port-forward &lt;pod&gt; 8088:8088 参考 Use wscat to Connect to a WebSocket API]]></content>
      <categories>
        <category>Awesome</category>
      </categories>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thin 原理剖析]]></title>
    <url>%2F2019%2F07%2F25%2Fthin-under-a-microscope%2F</url>
    <content type="text"><![CDATA[Thin - A small and fast Ruby web server 前提知识IO 模型类 Unix I/O 系统的基本模型是一个能够被随机访问或有序访问的字节序列，进一步抽象为一个数据字节流或一个 IO 流。无论怎样，用户空间不能去访问和控制。 流简单的理解，流就是 IO 对象。 文件描述符在 *nix 中，一切皆文件。每个文件都有一个文件描述符作为文件的引用。文件、管道、套接字都可以被文件描述符引用。 IO 调用IO 执行IO in Ruby12io = IO.new(1)io.puts 'Hello, 世界' Ruby 的 IO 对象 IO File Socket StringIO Tempfile SocketSocket 可读条件Socket 可写条件观察者模式发布/订阅模式事件驱动模式事件发射器（EventEmitter）一个简单实现，内部使用一个 hash 存储事件名及事件处理器（可调用对象），使用延迟调用技术实现。 emitter.on(eventName, listener) Adds the listener function to the end of the listeners array for the event named eventName. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of eventName and listener will result in the listener being added, and called, multiple times. emitter.emit(eventName[, …args]) Synchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each. 12345678910111213141516module EventEmitter def _handler_queue @_handler_queue ||= Hash.new &#123; |event_name, handler| h[event_name] = [] &#125; end def on(event_name, &amp;handler) _handler_queue[event_name] &lt;&lt; handler self end def emit(event_name, *args) _handler_queue[event_name].each do |handler| handler.call(*args) end endend 事件循环（EventLoop）一个简单实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class EventLoop attr_reader :event_queue def initialize @event_queue = [] end def &lt;&lt;(event) @event_queue &lt;&lt; event event.on(:close) do @event_queue.delete(event) end end def io(io) event = Event.new(io) self &lt;&lt; event event end def open(file, *args) io File.open(file, *args) end def connect(host, port) io TCPSocket.new(host, port) end def listen(host, port) server = Server.new(TCPServer.new(host, port)) self &lt;&lt; server server.on(:accept) do |connection| self &lt;&lt; connection end server end def start @running = true tick while @running end def stop @running = false end def tick @event_queue.each do |event| event.handle_read if event.readable? event.handle_write if event.writable? end endend 工作原理参考 一文读懂高性能网络编程中的I/O模型 浅谈 Thin 的事件驱动模型 Node.js v12.7.0 Documentation Event loops demystified Event Loop and the Big Picture — NodeJS Event Loop Part 1 How TCP Sockets Work]]></content>
      <categories>
        <category>Microscope</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超赞文章合集]]></title>
    <url>%2F2019%2F07%2F24%2Fawesome-article%2F</url>
    <content type="text"><![CDATA[好文章！ 文章列表技术 Event loops demystified NodeJS事件循环 Part 1 How TCP Sockets Work The TTY demystified 集群资源调度系统设计架构总结]]></content>
      <categories>
        <category>Awesome</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重拾 CSS]]></title>
    <url>%2F2019%2F07%2F13%2Ffall-with-css-again%2F</url>
    <content type="text"><![CDATA[每天半小时，在“肥仔”旁边看书，最近看《精通 CSS》，“肥仔”是我的同事，搞前端。 摘录了书中的知识框架，需要填充一些细节，又感觉无趣，不搞前端有段时间了，工作中没有机会，稍记后补。 响应式布局——页面布局——内容布局——定位——浮动及清除——排版和特效。 基础通过关注点分离，在宏观上将网页拆分为结构、样式、行为三个方面。HTML 负责结构，CSS 负责样式，JavaScript 负责行为，简直完美！当然，关注点分离策略可以具体到每个方面。 渐进增强是另一个总要的策略，保持特性向后兼容。 结构HTML 负责网页的结构，创建结构化、语义化 HTML 文档是添加样式/行为的基础。 语义化标签： header nav main aside article footer 扩展 HTML 语义？ 包装元素尽可能保持最简结构，必要时添加包装元素，以支持浮动、定位、布局。 接入点基于适当的样式接入点，利用多种选择器，应用样式规则。 选择器 ID 选择器 类型选择器 类选择器 后代选择器 子选择器 同辈选择器 通用选择器 属性选择器 伪元素选择器 伪类（结构化伪类、表单伪类） 重要性 标注为 !important 的用户样式； 标注为 !important 的作者样式； 作者样式； 用户样式； 浏览器（或用户代码）的默认样式。 特殊性基于位置计算规则的特殊性，不同选择器对应不同的数值，规则的特殊性等于每个选择器的累加数值。 行内样式，a 为 1； b 等于 ID 选择器的数目； c 等于类选择器、伪类选择器、属性选择器的数目； d 等于类型选择器和伪元素选择器的数目。 继承层叠次序重要性高的样式覆盖重要性低的样式；特殊性高的样式覆盖特殊性低的样式；后定义的样式覆盖先定义的样式。 应用样式 行内样式； 内联样式； 外部样式； 盒模型1234&#123; display: inline-block; box-sizing: border-box;&#125; 基本概念宽度、高度、内边距、边框、外边距。 块级盒子从上到下，垂直堆叠。 行内盒子从左到右，水平展开。 行盒子一行文本构成一个行盒子。 123span &#123; line-height: 36px;&#125; 匿名盒子格式化上下文（模型）包含块/起始包含块外边距折叠在正常文档流中，块级盒子发生外边距折叠。 布局页面布局12345678.grid &#123; margin: 0 auto; display: grid; grid-template-rows: repeat(2, 1fr); grid-template-columns: repeat(5, 1fr); grid-column-gap: 20px; grid-row-gap: 20px;&#125; 内容布局12345678910.flexbox .row &#123; display: flex;&#125;.flexbox .col &#123; display: flex; flex-direction: column;&#125;.flexbox .col &gt; * &#123; flex: 1;&#125; 定位12345div &#123; position: fixed; top: 50%; left: 50%;&#125; 相对定位12345div &#123; position: relative; top: 50%; left: 50%;&#125; 绝对定位12345div &#123; position: absolute; top: 50%; left: 50%;&#125; 浮动12345678910.container float &#123;&#125;// 清除.container::after &#123; content: ''; display: block; clear: both;&#125; 排版特效变换过渡动画滤镜]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sinatra 原理剖析]]></title>
    <url>%2F2019%2F07%2F13%2Fsinatra-under-a-microscope%2F</url>
    <content type="text"><![CDATA[Sinatra 是一门基于 Ruby 的领域专属语言，致力于轻松、快速地创建网络应用。 剖析 Sinatra 有助于进一步了解 Rack 的工作原理，有助于了解一个 Web 框架的应有的特性及其实现。 Sinatra 的实现涉及到正则表达式、Ruby 元编程特性，还有 HTTP 相关知识，在剖析的过程中，都可以进行回顾和总结。 一个例子摘自 Sinatra 官网。 123456# app.rbrequire 'sinatra'get '/' do 'Hello, 世界!'end 1ruby app.rb 在浏览器中访问 http://localhost:4567/。 程序是怎样跑起来的Sinatra 是怎样启动 Thin 服务器的？Sinatra 是如何响应请求的？ 启动服务器Sinatra 工作原理 &amp; Sinatra Explained 都解释了 Sinatra 的启动过程。 让我们一起跟踪一下 Sinatra 的启动过程： 打开 pry ！ 1234567require 'sinatra'# =&gt; trueget '/' do 'Hello, 世界!'end# =&gt; [#&lt;Mustermann::Sinatra:"/"&gt;, [], #&lt;Proc:0x00007fc84f3925a0@/sinatra/base.rb:1635&gt;]# 延迟执行 在 pry 中运行例子程序，是不会启动 Thin 的。那 Thin 是如何被启动的？其实不需要太多尝试，Thin 的启动应该发生在 app.rb 运行之后，这怎么可能做到？ 12345678# lib/sinatra/main.rbrequire 'sinatra/base'module Sinatra # ...snip... at_exit &#123; Application.run! if $!.nil? &amp;&amp; Application.run? &#125;end 在 app.rb 运行结束之后，执行 1Application.run! if $!.nil? &amp;&amp; Application.run? $!The exception information message set by ‘raise’.$0Contains the name of the script being executed. May be assignable. 进一步跟踪一下： 123456789101112131415161718192021222324252627282930# lib/sinatra/main.rbrequire 'sinatra/base'module Sinatra class Application &lt; Base set :run, Proc.new &#123; File.expand_path($0) == File.expand_path(app_file) &#125; # ...snip... end at_exit &#123; Application.run! if $!.nil? &amp;&amp; Application.run? &#125;endSinatra::Application.run?# =&gt; true$ Sinatra::Application.run!# =&gt;=begin begin start_server(handler, server_settings, handler_name, &amp;block) rescue ...snip... end=end$ Sinatra::Application.start_server# -&gt; handler.runSinatra::Application.send(:detect_rack_handler)# =&gt; Rack::Handler::Thin 梳理一下： 123Application.run! -&gt; Application.start_server -&gt; handler.start监听 4567 端口 ! 处理请求1234567891011extend Sinatra::Delegator# 在顶层上下文中可以访问 get 方法$ get# =&gt;define_method(method_name) do |*args, &amp;block| return super(*args, &amp;block) if respond_to? method_name Delegator.target.send(method_name, *args, &amp;block)end呃？！ 经过整理，Sinatra 请求处理流程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950module Sinatra class Base def call(env) dup.call!(env) end def call!(env) invoke &#123; dispatch! &#125; end def dispatch! route! end def route! route_eval &#123; [200, &#123;&#125;, 'Hello, Sinatra!'] &#125; end def route_eval throw :halt, yield end def invoke res = catch(:halt) &#123; yield &#125; end class &lt;&lt; self def settings self end def get(path, opts = &#123;&#125;, &amp;block) route('GET', path, opts, &amp;block) end def route(verb, path, options = &#123;&#125;, &amp;block) @routes = &#123;&#125; (@routes['GET'] ||= []) &lt;&lt; [nil, [], block] end def call(env) new.call(env) end end end class Application &lt; Base endend 代理的实现如果我们想在顶层上下文中，引用 Sinatra::Base.get 方法，我们可以怎么做？ 123456789101112get '/' do "Hello, 世界"end# =&gt; NoMethodError: undefined method `get' for main:Object# include would include the module in Object# extend only extends the `main` objectrequire 'sinatra/base'extend Sinatra::Delegator 在 Sinatra::Delegator 中定义私有方法，在顶层上下文中调用 extend Sinatra::Delegator，Sinatra::Delegator 的私有方法将成为 main 对象的私有方法，确切的说，是 main 的单件类的私有实例方法。 Sinatra::Delegator 实现如下，定义了一个类实例变量 target，作为代理目标，定义了一个类方法 delegate，使用 deleate 方法定义了一些列私有实例方法，代理到 target。代码实现如下： 12345678910111213141516171819202122module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &amp;block| return super(*args, &amp;block) if respond_to? method_name Delegator.target.send(method_name, *args, &amp;block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :link, :unlink, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class &lt;&lt; self attr_accessor :target end self.target = Applicationend 文档 阅读代码时，应该尽可能地利用任何能够得到地文档。 Sinatra READMESinatra 工作原理Sinatra Explained 特性Sinatra 几乎包含了一个 Web 框架的所有特性。 路由 浏览器重定向 静态文件 视图 / 模板 过滤器 辅助方法 错误处理 会话 日志 缓存控制 配置 &amp; 环境 接下来，将对部分特性进行剖析。 Rack 中间件架构从责任/角色/协作视角看 Sinatra，我们可以获得哪些架构上的认知。 我们将 Sinatra 特性分为框架特性和非框架特性，如果将 Sinatra 看成是一个黑箱，那么框架特性在黑箱内部，非框架特性在黑箱边界。作为 Rack 应用，Sinatra 需要响应 call 方法，同时负责启动应用服务器。 Sinatra 将应用启动的责任分配给 Sinatra::Application，但是代理给 Sinatra::Base。其实，Sinatra::Application 的责任都代理给了 Sinatra::Base。 代码结构Sinatra 使用标准的 Gem 项目结构，主要实现位于文件 main.rb 和 base.rb 中 。 12345678910111213.├── sinatra│ ├── base.rb│ ├── images│ │ ├── 404.png│ │ └── 500.png│ ├── indifferent_hash.rb│ ├── main.rb│ ├── show_exceptions.rb│ └── version.rb└── sinatra.rb2 directories, 8 files 统计12345678910111213141516171819brew install cloccloc .# sinatra (2.0.5)32 text files.32 unique files.6 files ignored.github.com/AlDanial/cloc v 1.82 T=0.16 s (167.6 files/s, 229647.0 lines/s)-------------------------------------------------------------------------------Language files blank comment code-------------------------------------------------------------------------------Markdown 17 7457 0 25255Ruby 9 430 345 2131-------------------------------------------------------------------------------SUM: 26 7887 345 27386------------------------------------------------------------------------------- Trick1# Sinatra::Base.set 私有方法在 Ruby 中，方法查找和方法调用是两个独立的过程，obj.methods 中的方法都是可以显式指定接收者的，obj.private_methods 中的方法只能通过隐式的接收者调用。 在编程过程中，其实不需要关注私有方法存在对象的类中还是单件类中。如果清楚其中的实现，当然更好！具体参看 *methods 的 API 文档。 1234567891011121314151617181920212223242526272829class Aprivate def a 'private a' endenda = A.newa.methods.include? :a # =&gt; falsemodule Mprivate def m 'M#m' endendextend Mself.methods.include? :m # =&gt; falseself.private_methods.include? :mm #=&gt; 'M#m'class &lt;&lt; selfprivate def sm 'self#sm' endendself.singleton_methods.include? :sm # =&gt; false]]></content>
      <categories>
        <category>Microscope</category>
      </categories>
      <tags>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 本地安装 Consul]]></title>
    <url>%2F2019%2F07%2F12%2Fmacos-consul%2F</url>
    <content type="text"><![CDATA[在 macOS 中，使用 Homebrew 安装 Consul，使用 HomebrewServices 启动 Consul，重启后数据丢失。记录解决方法如下。 安装 Consul1brew install consul 启动 Consul1brew services start consul 重启 Consul1brew services restart consul 重启 Consul 后，数据丢失！ Why? 修改 Consul 启动模式。 12345678910111213141516171819202122232425262728293031323334353637# code /Users/user/Library/LaunchAgents/homebrew.mxcl.consul.plist 不起作用# code /usr/local/Cellar/consul/1.4.0/homebrew.mxcl.consul.plist&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt; &lt;dict&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;dict&gt; &lt;key&gt;SuccessfulExit&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;homebrew.mxcl.consul&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/opt/consul/bin/consul&lt;/string&gt; &lt;string&gt;agent&lt;/string&gt; &lt;string&gt;-server&lt;/string&gt; &lt;string&gt;-data-dir&lt;/string&gt; &lt;string&gt;/usr/local/opt/consul/data&lt;/string&gt; &lt;string&gt;-bind&lt;/string&gt; &lt;string&gt;127.0.0.1&lt;/string&gt; &lt;string&gt;-bootstrap-expect&lt;/string&gt; &lt;string&gt;1&lt;/string&gt; &lt;string&gt;-ui&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;WorkingDirectory&lt;/key&gt; &lt;string&gt;/usr/local/var&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/usr/local/var/log/consul.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/usr/local/var/log/consul.log&lt;/string&gt; &lt;/dict&gt;&lt;/plist&gt; Property List(属性列表文件) 属性列表（Property List）文件是一种用来存储序列化后的对象的文件。Plist文件通常用于储存用户设置，也可以用于存储捆绑的信息。从Mac OS X 10.5开始，Apple也提供了用于编辑，创建和写入plist文件的接口。 Homebrew Servicesbrew-services]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重拾 Ruby]]></title>
    <url>%2F2019%2F07%2F11%2Ffall-with-ruby-again%2F</url>
    <content type="text"><![CDATA[从 2018 年底至今，写了快一年的 Scala 应用程序，重拾一下 Ruby。近乎涉及 Ruby 开发的所有方面，当然不可能全面。 写一份 Ruby 攻略，而不是写一份参考手册。 Ruby 进程/线程/网络编程，参看 谈谈 Rack 的协议与实现。 通过 Ruby 的应用服务器设计与实现，理解 Ruby 进程/线程/网络编程。 Ruby 编程1233.times do puts "Ruby is a programmer's best friend"end 工具使用 RVM 管理 Ruby 的版本；使用 Pry 替代 irb，Pry 是阅读 Ruby 项目源码的一件利器。 RVM1234567891011rvm list knownrvm install ruby-headrvm use ruby-headrvm gemset listrvm gemset create devrvm use --ruby-version ruby-head@dev Pry12345require 'rack'$ Rack::Server.start$ Rack::Server#initialize REPL实验驱动开发：读取-求值—打印-循环。快速实验 API 用法，一步步写出代码。 语言特性面向对象编程见 《Ruby 元编程》。 1234567891011121314151617class Greeting def initialize(text) @text = text end def welcome @text endendg = Greeting.new('Hello, Ruby')g.instance_variablesg.classg.class.instance_methods(false)g.class.superclassg.class.ancestorsg.singleton_class 函数式编程见《函数式编程思想》。函数式语言特性，包括不变性、引用透明性、模式匹配、列表推导式、高阶函数、组合函数、函子、可应用函子、单子等。Ruby 支持部分函数式语言特性。 1234a = [1, 2, 3]a.map &#123; |item| item * 3 &#125;a.filter &#123; |item| item.odd? &#125;a.reduce(0) &#123; |a, b| a + b &#125; 并发编程见《理解 Unix 进程》和《理解 Ruby 线程》。 12thr = Thread.new &#123; puts "Whats the big deal" &#125;thr.join 异步编程Asynchronous Ruby 分布式编程见 《分布式 Ruby 编程》。 小结Ruby 是一门通用语言，支持多种编程范式。Ruby 优雅而灵活，是程序员的朋友。 Ruby 元编程一图胜千言。 12345678class K; endo = K.newclass &lt;&lt; o def m puts '#o #m' endendo.m include 和 extend简单地说，Ruby 使用继承实现 include 和 extend。在 Ruby 中，include 和 extend 都是方法，不是关键字，虽然这样强调毫无应用价值。 Ruby 原理剖析见 《Flex &amp;&amp; Bison》 和 《深入理解程序设计》。 Ruby 进程阅读 ruby/process.c。 123456789101112voidrb_define_global_function(const char *name, VALUE (*func)(ANYARGS), int argc)&#123; rb_define_module_function(rb_mKernel, name, func, argc);&#125;voidrb_define_module_function(VALUE module, const char *name, VALUE (*func)(ANYARGS), int argc)&#123; rb_define_private_method(module, name, func, argc); rb_define_singleton_method(module, name, func, argc);&#125; Ruby 对进程相关的系统调用进行了封装，但只使用了模块。 123456789101112131415161718192021222324252627282930313233343536# 摘自 《理解 Unix 进程》Process.pid # 进程皆有标识Process.ppid # 进程皆有父STDIN.filenoSTDOUT.filenoSTDERR.fileno # 进程皆有描述符Process.getrlimit(:NOFILE) # 进程皆有资源限制ENV # 进程皆有环境ARGV # 进程皆有参数$PROGRAM_NAME # 进程皆有名exit 0 # 进程皆有退出码fork &#123; sleep 3 &#125; # 进程皆可衍生 -&gt; 孤儿进程，友好的进程Process.wait # 进程可待 -&gt; 看顾进程, 僵尸进程trap(:INT, "IGNORE") # 进程皆可获得信号# 进程皆可互通reader, writer = IO.pipe child_socket, parent_socket = Socket.pair(:UNIX, :DGRAM, 0)Process.daemon # 守护进程IO.popen('less', 'w') &#123; |stream| stream.puts 'some data' &#125; # 生成终端进程 关注 Ruby 进程生成、互通、信号等几个方面。 Ruby 线程由于 Ruby 的 GIL，Ruby 线程可以并发，但不能并行。 1Thread.main == Thread.current # =&gt; true Ruby 网络编程Ruby 网络编程，即 Socket 编程，重点在于理解 IO 模型。 1234567891011121314151617181920212223242526require 'socket'# Client# 创建socket = Socket.new(:INET, :STREAM)# 绑定# 连接remote_addr = Socket.pack_sockaddr_in(8888, '0.0.0.0')socket.connect(remote_addr)# 关闭socket.close# Server# 创建socket = Socket.new(:INET, :STREAM)# 绑定addr = Socket.pack_sockaddr_in(8888, '0.0.0.0')socket.bind(addr)# 侦听socket.listen(7)# 接受connection, _ = socket.accept # echo hi | nc localhost 8888# 关闭connection.close Ruby 分布式编程Ruby 应用一图胜千言。 RackRack 接口规范 使用 Rack，需要提供一个可调用对象，取一个环境变量，返回一个包含 HTTP 响应状态码/响应头/响应体 的数组。当 Ruby 应用服务器接受一个请求，将请求信息封装到一个环境变量中，调用应用对象，经过应用中间件处理，将返回的数组作为请求的响应信息。 12# config.rurun Proc.new &#123; |env| ['200', &#123;'Content-Type' =&gt; 'text/html'&#125;, ['get rack\'d']] &#125; Rack 工作原理：执行 rackup 后，读取 config.ru 文件，获取 app 对象，当没有配置时，取默认应用服务器，取默认配置，取默认中间件对 app 对象封装成包含中间件的 app 对象，启动应用服务器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ Rack::Server.start# =&gt; server.run wrapped_app, options, &amp;blk$ Rack::Server#server# -&gt; Rack::Handler.default# =&gt; Rack::Handler::Puma$ Rack::Server#default_options# =&gt;=begin&#123; :environment =&gt; 'development', :pid =&gt; nil, :Port =&gt; 9292, :Host =&gt; 'localhost', :AccessLog =&gt; [], :config =&gt; "config.ru"&#125;=end$ Rack::Server#wrapped_app# -&gt; Rack::Server#build_app# -&gt; Rack::Server#app# =&gt;cfgfile = ::File.read(config)cfgfile.sub!(/^__END__\n.*\Z/m, '')app = Rack::Builder.new &#123; run Proc.new &#123; |env| ['200', &#123;'Content-Type' =&gt; 'text/html'&#125;, ['get rack\'d']] &#125;&#125;.to_app$ Rack::Server#build_app# =&gt;=begin def build_app(app) middleware[options[:environment]].reverse_each do |middleware| middleware = middleware.call(self) if middleware.respond_to?(:call) next unless middleware klass, *args = middleware app = klass.new(app, *args) end app end=end$ Rack::Server.default_middleware_by_environment# =&gt;=begin&#123; "deployment"=&gt; [[Rack::ContentLength], [Rack::Chunked], #&lt;Proc:0x00007fedad041738@/rack/server.rb:224 (lambda)&gt;, [Rack::TempfileReaper] ], "development"=&gt; [[Rack::ContentLength], [Rack::Chunked], #&lt;Proc:0x00007fedad040540@/rack/server.rb:224 (lambda)&gt;, [Rack::ShowExceptions], [Rack::Lint], [Rack::TempfileReaper]]&#125;=end 可执行代码如下： 123456789101112131415161718192021222324252627282930313233343536373839require 'rack'class &lt;&lt; self def options &#123; :environment =&gt; 'development', :pid =&gt; nil, :Port =&gt; 9292, :Host =&gt; 'localhost', :AccessLog =&gt; [], :config =&gt; "config.ru" &#125; end def blk nil end def server Rack::Handler::Thin end def app Rack::Builder.new &#123; run Proc.new &#123; |env| ['200', &#123;'Content-Type' =&gt; 'text/html'&#125;, ['get rack\'d']] &#125; &#125;.to_app endendRack::Server.default_middleware_by_environment['development'].reverse_each do |middleware| middleware = middleware.call(self) if middleware.respond_to?(:call) next unless middleware klass, *args = middleware app = klass.new(app, *args)endwrapped_app = appserver.run wrapped_app, options, &amp;blk 后面涉及两部分内容，一是 Ruby 应用服务器处理请求和响应请求，二是 Ruby 应用框架及 Ruby 应用的设计与实现。 SinatraSinatra 应用12345678# app.rbrequire 'sinatra'get '/' do 'Hello world!'end# $ ruby app.rb =&gt; http://localhost:4567 入口在哪里？服务是怎么启动的？跟踪一下！ 12345678910111213141516171819202122232425262728293031323334require 'sinatra'$ get# =&gt;=begin define_method(method_name) do |*args, &amp;block| return super(*args, &amp;block) if respond_to? method_name Delegator.target.send(method_name, *args, &amp;block) end=end$ Sinatra::Delegator.target# =&gt; attr_accessor :target# =&gt; Applicationget '/' do 'Hello world!'end# =&gt; [#&lt;Mustermann::Sinatra:"/"&gt;, [], #&lt;Proc:0x00007f9cba0c8f88@/sinatra/base.rb:1635&gt;]# 惊喜！获得一个可调用对象！# 入口!at_exit &#123; Application.run! if $!.nil? &amp;&amp; Application.run? &#125;# 当 app.rb 运行结束后执行handler = Sinatra::Application.send(:detect_rack_handler)$ Sinatra::Application.run!# -&gt; Sinatra::Application.start_server# -&gt; handler.run 看一下 at_exit： Converts block to a Proc object (and therefore binds it at the point of call) and registers it for execution when the program exits.If multiple handlers are registered, they are executed in reverse order of registration. Sinatra 启动服务器的方式还是值得学习的！ Sinatra 剖析见 Sinatra 原理剖析 ThinRailsPuma]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理的设计与重构]]></title>
    <url>%2F2019%2F01%2F19%2Fexception-processing%2F</url>
    <content type="text"><![CDATA[《异常处理的设计与重构》较为系统地讲述了异常处理，但是叙述多为繁冗，在此提取实用的内容，摘录并整理如下（该书未涉及函数式异常处理）。 异常处理异常处理很重要，影响软件的健壮性，影响用户体验，继而影响公司的盈利。 关于异常处理，我们要了解以下定义： 缺陷（fault）：瞬时缺陷/间歇缺陷/永久缺陷 | 设计缺陷/组件缺陷 | 开发缺陷/物理缺陷/交互缺陷 错误（error） 失败/失效（failure） 异常/例外（exception）：在程序设计语言中错误与失败的统称 缺陷是错误的起因，可能会导致失败。 异常上下文异常上下文是当异常发生的时候，异常处理程序可以从异常对象所获得的相关信息。 设计语义清楚、层级分明的异常类。 异常处理机制 表达：如何表达异常？符号/异常实例/其他对象 声明：往外传递的异常是否需要声明？预期异常/非预期异常 通知：如何产生一个异常的实例？同步异常/异步异常|内部异常/外部异常 传递：如何传递异常？显式/隐式 附加：异常处理程序可绑定到何种程序区块？代码块/函数/对象/类 处理：针对异常，如何找到可以处理它的异常处理程序？静态范围/动态范围 继续：异常发生之后，程序的控制流程该如何进行？终止/恢复/重试 清理：无论是否发生异常，如何让程序清理资源以保持在正确的状态？ 可靠性检查：因为异常处理机制所造成的问题，程序语言提供何种检查？静态检查/动态检查 并发性：程序语言对于并行处理程序，提供多少异常处理的支持？支持/不支持 异常安全性 不保证（可能正确，也可能错误） 基本保证（无泄漏保证） 强烈保证（具备认可或复原/全部或没有的语义，要么成功，要么失败） 不抛保证（失效透明） 异常处理策略当程序执行时发生异常，首要任务就是要找到异常发生的根本原因，其次就是要厘清“谁该负责”处理这个异常。 确定服务的生产者和消费者，确定服务调用的前置条件和后置条件，确定异常处理责任。 所有的异常状况都有相应的报告。 报告语义清楚的异常，以便协助开发团队缩短事后除错时间。 针对不同的健壮性等级做不同的异常设计：错误报告 -&gt; 状态恢复 -&gt; 行为恢复。 考虑容错设计。 缺陷处理方法 缺陷避免 缺陷容忍（通过错误检测与系统恢复手段，避免服务失效） 缺陷移除 缺陷预测 命令式异常处理Try 实现需求 为状态恢复做准备或制作检查点 Catch 进行错误处理与缺陷处理 报告错误状况 控制重试流程 Finally 释放资源 清除检查点 异常处理设计 用途观点（失败/通知） 设计观点（声明/未声明|预期异常/非预期异常） 处理观点（可恢复/不可恢复） 工具支持观点（提示/无提示） 流程观点 要借助异常的上下文来确定异常的用途。 异常处理坏味道 返回码 忽略已查异常 忽略异常 未保护主程序 空的异常处理程序 嵌套 Try 语句 粗心的资源清理 异常处理重构清除异常处理的坏味道（略)]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐歌词爬虫]]></title>
    <url>%2F2019%2F01%2F19%2Fnetease-music-lyric-crawler%2F</url>
    <content type="text"><![CDATA[自打使用 MacBook，就一直使用 Netease Music。最近听到林子祥的《在水中央》，感觉歌词雅致，旋律优美。想做一件事，把歌词爬下来，解析成带粤语拼音注解的歌词。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python3# import sys# sys.path.append('/Users/zhenyuanlau/GitHub/kata/crawler/netease-music/')# import demo# import importlib# importlib.reload(demo)from bs4 import BeautifulSoupimport osimport reimport requestsimport sysdef http_get(url): headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36', 'Referer': 'http://music.163.com', 'Host': 'music.163.com' &#125; try: return requests.get(url, headers = headers) except: print('request error') passdef get_artist_info(html): soup = BeautifulSoup(html, 'lxml') links = soup.find('ul', class_ = 'f-hide').find_all('a') song_ids = [] song_names = [] for link in links: song_id = link.get('href').split('=')[-1] song_name = link.get_text() song_ids.append(song_id) song_names.append(song_name) return zip(song_names, song_ids)def get_lyric(song_id): url = f'http://music.163.com/api/song/lyric?id=&#123;str(song_id)&#125;&amp;lv=1&amp;kv=1&amp;tv=-1' response = http_get(url).json() initial_lyric = response['lrc']['lyric'] regex = re.compile(r'\[.*\]') final_lyric = re.sub(regex, '', initial_lyric).strip() return final_lyricdef write_lyric(song_name, lyric): print(f'正在写入歌曲: &#123;song_name&#125;') with open(f'/tmp/lyrics/&#123;song_name&#125;.txt', 'a', encoding='utf-8') as fp: fp.write(lyric)def parse_lyric(song_name): # print(sys.getdefaultencoding()) with open(f'/tmp/lyrics/&#123;song_name&#125;.txt', 'rt') as fp: data = fp.read().replace('\n', '') print(set(data)) # for line in fp: # print(line)if __name__ == '__main__': if not os.path.exists('/tmp/lyrics'): os.makedirs('/tmp/lyrics') artist_id = input('请输入艺人 ID: ') artist_url = f'http://music.163.com/artist?id=&#123;artist_id&#125;' response = http_get(artist_url).text artist_infos = get_artist_info(response) for artist_info in artist_infos: lyric = get_lyric(artist_info[1]) write_lyric(artist_info[0], lyric) 剖析Python 跟 Ruby 一样，提供了一个交互式编程环境。 Python 安装12alias python='python3'alias pip='pip3' Python 包管理Ruby 有好用的 Bundler；Python 显得凌乱一些，pip/virtualenv/pipenv，选择 pipenv，最接近 Bundler。 12345pip freeze | xargs pip uninstall -ypipenv install requestspipenv install lxml # 一直 locking, SBT, Ctrl-Cpipenv install # OKpipenv python music/lyric.py Python 入门Python 入门指南Python Cookbook 3rd Edition Documentation Python 实践就语言层面，比 Scala 好上手多了，大概有 Ruby 开发经验的缘故。 工作中使用 Python 写数据迁移脚本。 待做生成注解版本歌词。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRPC]]></title>
    <url>%2F2019%2F01%2F02%2Fgrpc%2F</url>
    <content type="text"><![CDATA[使用 gRPC 实现微服务间通信。 进程进程是 Unix的两大基石之一，另一个是文件。理解Unix进程，有利于理解Unix编程模型。 基本概念进程 - 守护进程/终端进程、孤儿进程、友好进程、僵尸进程。 进程皆有 标识、父亲、文件描述符、资源限制、环境、参数、名字、退出码。 进程皆可 衍生、等待、获得信号、互通。 以上是Unix进程相关的基本概念，取自《理解Unix进程》的目录。 12345678910111213141516171819202122232425262728293031# 标识puts Process.pid# 父进程puts Process.ppid# 文件描述符passwd = File.open('/etc/passwd')puts passwd.fileno# 标准流puts STDIN.filenoputs STDOUT.filenoputs STDERR.fileno# 软限制p Process.getrlimit(:NOFILE)# 环境p ENV# 参数p ARGV# 名字p $PROGRAM_NAME# 衍生fork do p Process.ppidend 关注点本文奉行一个观点，即无需了解底层的实现，重点应该放在如何使用API实现有用的功能，并尽可能关注如何完成实际任务。不过有时候，不够了解底层实现会无法正确地使用某种特性。这种情况下，需要了解一些必要的细节，以便理解某些概念。 本文主要关注 Unix 进程互通，即进程间通信。 进程间通信 IPC管道匿名管道(Pipe)1ls | sort -n 命名管道(FIFO)进程 Reader 123456789101112131415161718192021#!/bin/bashpipe=/tmp/pipetrap "rm -f $pipe" EXITif [[ ! -p $pipe ]]; then mkfifo $pipefiwhile truedo if read line &lt;$pipe; then if [[ "$line" == 'quit' ]]; then break fi echo $line fidoneecho "Reader exiting" 进程 Writer 1234567891011121314#!/bin/bashpipe=/tmp/pipeif [[ ! -p $pipe ]]; then echo "Reader not running" exit 1fiif [[ "$1" ]]; then echo "$1" &gt;$pipeelse echo "Hello from $$" &gt;$pipefi 进程 Reader 通过 mkfifo 创建一个命名管道，并读取管道内容；进程 Writer 向命名管道写入内容。 应用用于具有亲缘关系（父子关系、兄弟关系）的进程间通信，用户自己创建管道，并完成读写操作。 套接字服务器（侦听者）123456require 'socket'Socket.tcp_server_loop(8888) do |connection| puts connection.read connection.closeend 客户端（发起者）1234Socket.tcp('0.0.0.0', 8888) do |connection| connection.write"GET / HTTP/1.1\r\n" connection.closeend 本地 IPC 使用Unix域套接字; 远程IPC 使用TCP 套接字。 远程过程调用RPCRPC调用流程Caller &lt;– call/return —&gt; Client Stub &lt;– send/receive —&gt; Server Stub &lt;– call/return —&gt; Callee 基本组件Server12345678910111213141516171819202122232425262728293031require 'socket'class ServerStub class &lt;&lt; self def start stub = ServerStub.new(8888) stub.run end end def initialize(port) @server = TCPServer.new(port) end def run Socket.accept_loop(@server) do |connection| request = connection.read method, args = Marshal.load(request) response = send(method.to_sym, *args) data = Marshal.dump(response) connection.write(data) connection.close end end def method_missing(name, *args) 'hi' endendServerStub.start Client12345678910111213141516171819202122232425262728293031require 'socket'# Client Stubclass ClientStub def initialize(address) @host, @port = address.split(':') @client = TCPSocket.new(@host, @port) end def method_missing(name, *args) data = Marshal.dump([name, args]) @client.write(data) @client.close_write data = @client.read message = Marshal.load(data) @client.close message endendclass Client class &lt;&lt; self def main stub = ClientStub.new('localhost:8888') message = stub.greet('hello') p "Greeting: #&#123;message&#125;" end endendClient.main 支撑技术 服务注册与发现 网络通信 序列化/反序列化 GRPC例子大体实现逻辑 PB 协议 服务端/客户端 Stub 生成器 gRPC 框架]]></content>
      <categories>
        <category>Microservices</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Start Up 2019]]></title>
    <url>%2F2019%2F01%2F01%2Fstart-up-2019%2F</url>
    <content type="text"><![CDATA[2019 年回顾和总结！ 2018 年回顾2016年8 月17日～2018年8月17 日: 无二之旅的两年大一有幸被导师选中，做了一年的数据挖掘，期间看了大量的英文资料。大二有幸遇到 LAMP，尝试安装主流的Linux发型版本；使用Vim阅读和编写代码，尝试各种配置和插件；使用 PHP 开发一些玩具程序。大三有幸进入系里的实验室，参与了一些项目，组织过技术培训。大四有幸进入某公司实习，做 Web 开发和嵌入式开发；邂逅了 Ruby 和 Rails。 研一的课程比较多，期间看了 SICP 和 Coding 等经典书籍。研二有幸和几个同学负责导师的一个课题，使用 C# 开发。研三有幸入职无二之旅，做 Rails 开发。 在无二之旅，一个全栈工程师应该具备的技能，都有所增益，得到了很好的锻炼。 2018年8月24 日至今：GrowingIO的三个月Ruby –&gt; Scala， Rails –&gt; Play， 单体架构 –&gt; 微服务架构。转型中，遇到一些问题，心态上的，技术上的，能力上的。 总结没有拿的出手的项目，也没有拿的出手的文章。过去的就过去了，不再提了！ 2019 年计划 写博客（每两周一篇） 造轮子（与博客同步） 轻断食（控制饮食） 轻健身（每天跑步半小时） 展望完成Ruby到Scala的转型，能够快速适应下一次技术转型；深入微服务实践，熟悉并发和分布式程序设计，接触大数据和机器学习。 进一步提升自我！]]></content>
      <categories>
        <category>Planning</category>
      </categories>
      <tags>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API 网关设计与实现]]></title>
    <url>%2F2018%2F10%2F05%2Fbuilding-api-gateway%2F</url>
    <content type="text"><![CDATA[基于 OpenResty 实现 API 网关。 概述使用微服务构建应用软件系统时，需要确定如何与微服务交互。我们知道，在微服务架构中，每个微服务通过API提供服务，API的形式有多种，REST、gRPC、GraphQL。我们可以直接或间接地访问API使用微服务。 一般地，我们会使用API网关构建微服务，所有请求都经过API网关处理，然后路由到合适的微服务。API网关有两个基本的功能，服务发现和服务调用，在这里我们只关注服务调用。 没有银弹，API网关有优点，也有缺点。 API 网关的主要功能： 服务发现 服务调用（请求分片、管理、缓存、静态响应、监控、负载均衡） 验证与鉴权 在这里，我们选择基于 OpenResty 设计和实现一个API网关。 OpenResty OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。我们使用 OpenResty 搭建 API网关，需要了解Nginx处理请求的流程以及 Lua 编程。 Nginx 工作原理Nginx 主要了解Nginx的基本配置、反向代理配置、负载均衡配置以及location指令。 默认配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 反向代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465upstream puma &#123; server unix:/var/www/puma.sock fail_timeout=0;&#125;server &#123; listen 80; client_max_body_size 4G; keepalive_timeout 10; error_page 500 502 504 /500.html; error_page 503 @503; server_name; root /var/www/public; try_files $uri/index.html $uri @puma; location @puma &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://puma; # limit_req zone=one; access_log /var/www/log/nginx.access.log; error_log /var/www/log/nginx.error.log; &#125; location ^~ /assets/ &#123; gzip_static on; expires max; add_header Cache-Control public; &#125; location = /50x.html &#123; root html; &#125; location = /404.html &#123; root html; &#125; location @503 &#123; error_page 405 = /system/maintenance.html; if (-f $document_root/system/maintenance.html) &#123; rewrite ^(.*)$ /system/maintenance.html break; &#125; rewrite ^(.*)$ /503.html break; &#125; if ($request_method !~ ^(GET|HEAD|PUT|PATCH|POST|DELETE|OPTIONS)$ )&#123; return 405; &#125; if (-f $document_root/system/maintenance.html) &#123; return 503; &#125; location ~ \.(php|html)$ &#123; return 405; &#125;&#125; 负载均衡12345678910111213upstream puma_servers &#123; ip_hash; server 192.168.10.13:80; server 192.168.10.14:80 down; server 192.168.10.15:80 max_fails=3 fail_timeout=20s; server 192.168.10.16:8080;&#125;server &#123; location / &#123; proxy_pass http://puma_servers; &#125;&#125; location 指令1234Syntax: location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @name &#123; ... &#125;Default: —Context: server, location Lua 程序设计过程抽象操作符12345678--&gt; 指数2 ^ 3 -- 8.0--&gt; 不等于1 ~= 0 -- true--&gt; 字符串连接"Hello" .. "World" -- HelloWorld 函数1234567891011121314151617181920--&gt; 先定义，后使用--&gt; 定义函数本质上是在定义变量function func () -- body print("Hello World")endfunc()--&gt; 允许有多个函数返回值function swap(a, b) b, aenda = 1b = 2a, b = swap(a, b) 控制结构1234567--&gt; 在语法上，与Ruby相近i = 1repeat print(i) i += 1until i &gt;= 3 FFI数据抽象数据类型12345--&gt; 基础数据类型--&gt; 在 Lua 中，函数也是一种数据类型--&gt; 元表 面向对象在 Lua 中，可以使用表和函数实现面向对象。将函数和相关的数据放置于同一个表中就形成了一个对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273--&gt; 封装-- account.lualocal _M = &#123;&#125;local mt = &#123; __index = _M &#125;function _M.deposit (self, v) self.balance = self.balance + vendfunction _M.withdraw (self, v) if self.balance &gt; v then self.balance = self.balance - v else error("insufficient funds") endendfunction _M.new (self, balance) balance = balance or 0 return setmetatable(&#123;balance = balance&#125;, mt)endreturn _M-- account_test.lualocal account = require("account")local a = account:new()a:deposit(100)local b = account:new()b:deposit(50)print(a.balance) --&gt; output: 100print(b.balance) --&gt; output: 50--&gt; 继承---------- base.lualocal _M = &#123;&#125;local mt = &#123; __index = _M &#125;function _M.upper (s) return string.upper(s)endreturn _M---------- more.lualocal base = require("base")local _M = &#123;&#125;_M = setmetatable(_M, &#123; __index = base &#125;)function _M.lower (s) return string.lower(s)endreturn _M---------- test.lualocal s_more = require("s_more")print(s_more.upper("Hello")) -- output: HELLOprint(s_more.lower("Hello")) -- output: hello Nginx 集成 Lua 第三方ngx_lua 模块用于处理单独配置无法解决的使用场景。OpenResty 是ngx_lua的官方来源，并提供了一组由Nginx、ngx_lua、一个Lua解释器以及一些第三方模块组成的Web平台，其中的第三方模块用于将Nginx转换为应用服务器。Nginx 并不支持同时使用ssi模块与ngx_lua模块处理请求。使用ngx_lua模块时，请记住当读取模块本身时，每个worker进程会加载一次全局变量。因此，最好的做法是声明所有变量为局部变量。在Nginx中使用ngx_lua模块有助于编写更高性能的应用程序。无需将逻辑传递到上游服务器，Lua便可处理该进程。你可以在Nginx请求处理的不同阶段调用ngx_lua 模块。许多 ngx_lua 配置指令直接引用它们影响到的请求阶段。根据请求处理链要使用Lua的位置，你可以使用响应的指令。加载Lua脚本来处理请求涉及使用lua_package_path指令指定查找脚本的位置，然后使用适当的_by_lua指令来执行该脚本。除了指令外，ngx_lua还可以使用某些功能与Nginx交互。Nginx中的任何变量集都可以在Lua脚本中通过ngx.var.VARIABLE_NAME 来访问。头文件在Lua中通过ngx.header.HEADER来访问。当使用Lua编写脚本时，如果要重用的话，请将Nginx变量放在局部变量中。（有助于防止内存膨胀) API 网关请求处理123456789101112131415161718192021222324252627282930location /api &#123; # Initialization Phase init_by_lua* init_worker_by_lua* # Rewrite/Access Phase ssl_certificate_by_* # if request secure set_by_lua* rewrite_by_lua* access_by_lua* # Content Phase content_by_lua*/balancer_by_lua* header_filter_by_lua* body_filter_by_lua* # Log Phase log_by_lua*&#125; 在了解了 Nginx 和 OpenResty 的请求处理流程之后，我们可以通过挂载（钩子）实现API网关功能。 例子123# 通过location实现API路由# 通过 access_by_lua*，挂载身份验证/服务解析的代码# 通过 header_filter_by_lua*，挂载跨域请求的代码 参考 使用 API 网关构建微服务 OpenResty 中文站 OpenResty 最佳实践 agentzh的 Nginx 教程 《Lua程序设计(第2版)》 《精通Nginx（第2版）》]]></content>
      <categories>
        <category>Microservices</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Nginx</tag>
        <tag>OpenResty</tag>
      </tags>
  </entry>
</search>
